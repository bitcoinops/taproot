#### 2.2.2: Signing with a tweaked 2-of-2 Musig key pairs

```
# Generate key pairs
privkey0 = ECKey().generate()
privkey1 = ECKey().generate()
pubkey0 = privkey0.get_pubkey()
pubkey1 = privkey1.get_pubkey()

# Create an aggregate MuSig pubkey
c_map, agg_pubkey = generate_musig_key([pubkey0, pubkey1])

# Apply challenge factors to keys
privkey0_c = privkey0 * c_map[pubkey0]
privkey1_c = privkey1 * c_map[pubkey1]
pubkey0_c = pubkey0 * c_map[pubkey0]
pubkey1_c = pubkey1 * c_map[pubkey1]
    
# Tweak musig public key
tweak = random.randrange(1, SECP256K1_ORDER)
agg_pubkey_tweaked = agg_pubkey.tweak_add(tweak)

# Nonce generation & aggregation
# Remember to negate the individual nonce values if required
k0 = generate_schnorr_nonce()
k1 = generate_schnorr_nonce()
R0 = k0.get_pubkey()
R1 = k1.get_pubkey()
R_agg, negated = aggregate_schnorr_nonces([R0, R1])
if negated:
    k0.negate()
    k1.negate()

# Signing and signature aggregation
msg = hashlib.sha256(b'msg').digest()

# One person must tweak keys
privkey0_c_tweaked = privkey0_c.add(tweak) 

# Sign individually and then aggregate signatures
s0 = sign_musig(privkey0_c_tweaked, k0, R_agg, agg_pubkey_tweaked, msg)
s1 = sign_musig(privkey1_c, k1, R_agg, agg_pubkey_tweaked, msg)
sig_agg = aggregate_musig_signatures([s0, s1], R_agg)

assert agg_pubkey_tweaked.verify_schnorr(sig_agg, msg)
print("Success!")
```

#### 2.2.5: Construct taproot output with tweaked public key
```
# Example key pair
privatekey = ECKey().set(102118636618570133408735518698955378316807974995033705330357303547139065928052, True)
internal_pubkey = privatekey.get_pubkey()

# Example tweak
taptweak = bytes.fromhex('2a2fb476ec9962f262ff358800db0e7364287340db73e5e48db36d1c9f374e30')

# Tweak the public key
# Method: use internal_pubkey.tweak_add()
taproot_pubkey = internal_pubkey.tweak_add(taptweak) 
taproot_pubkey_b = taproot_pubkey.get_bytes()

# Derive the bech32 address
# Method: set the first byte of taproot_pubkey to 0 or 1 and then call program_to_witness(version, pubkey)
taproot_pubkey_v1 = bytes([taproot_pubkey_b[0] & 1]) + taproot_pubkey_b[1:]
segwit_address = program_to_witness(1, taproot_pubkey_v1)

assert segwit_address == "bcrt1pq9lku0vuddzvcte8yvt3xct0dk6cjqeq2yzqp3vwpvh2e8afqpvqqyftl09"
print("Success! Segwit Address: {}".format(segwit_address))
```

##### 2.2.6: Spend taproot output with key path

```
# Complete output which returns funds to Bitcoin Core wallet.
dest_output = CTxOut(nValue=output_value-min_fee, scriptPubKey=scriptpubkey)
spending_tx.vout = [dest_output]

# Sign transaction with tweaked private key
# Method: use TaprootSignatureHash() to get the signature hash
# and then sign with a the tweaked private key
hash_types = [0,1,2,3,0x81,0x82,0x83]
sighash = TaprootSignatureHash(spending_tx, [output], hash_types[0])
tweaked_privkey = privkey.add(taptweak)
sig = tweaked_privkey.sign_schnorr(sighash)

# Construct transaction witness
witness = CScriptWitness()
witness.stack.append(sig)
witness_in = CTxInWitness()
witness_in.scriptWitness = witness
spending_tx.wit.vtxinwit.append(witness_in)

# Serialize transaction for broadcast
spending_tx_str = spending_tx.serialize().hex()
print("Serialized tx: {}\n".format(spending_tx_str))

# Test mempool acceptance
assert test.nodes[0].testmempoolaccept([spending_tx_str])[0]['allowed']
print("Success!")
```

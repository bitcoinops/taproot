#### 1.1.2 Verify that inverse nonce values `k` and `-k` generate inverse points `R` and `-R`

```
# Generate a random value in the secp256k1 field
k = random.randrange(1, SECP256K1_ORDER)

k_key = ECKey().set(k, True)
R = k_key.get_pubkey()

# Find the x- and y-coordinates from R
R_x = R.get_x()
R_y = R.get_y()

# Find k's inverse (SECP256K1_ORDER - k)
minus_k = SECP256K1_ORDER - k

minus_k_key = ECKey().set(minus_k, True)
minus_R = minus_k_key.get_pubkey()

# Find the x- and y-coordinates from -R
minus_R_x = minus_R.get_x()
minus_R_y = minus_R.get_y()

assert R_x == minus_R_x
assert SECP256K1_FIELD_SIZE - R_y == minus_R_y

print("Success!")
```

#### 1.1.3 Sign a message with Schnorr

```
msg = hashlib.sha256(b'message').digest()
d = ECKey().generate()
P = d.get_pubkey()

k = ECKey().generate()
R = k.get_pubkey()

# Check that nonce is quadratic residue modulo the field size
# If not, negate k
# Method: jacobi_symbol(int(y(R)), SECP256K1_FIELD_SIZE)
if jacobi_symbol(R.get_y(), SECP256K1_FIELD_SIZE) != 1:
    k.negate()

# Generate s = k + sha256(R_x|P|msg) * d
# Method: hashlib.sha256(bytes).digest() will give you the byte digest of the SHA256 of some bytes
# Turn that digest into a ECKey object called h, and then set s = k + h * d
h_b = hashlib.sha256(R.get_x().to_bytes(32, 'big') + P.get_bytes() + msg).digest()
h = ECKey().set(h_b, True)
s = k + h * d

# Generate sig = R_x|s
# Method: get the x bytes from R and concatenate with the secret bytes from s
sig = R.get_x().to_bytes(32, 'big') + s.secret.to_bytes(32,'big')

# Verify the signature
assert P.verify_schnorr(sig, msg)

print("Success!")
```

#### 1.1.4 Signing Schnorr with deterministic nonce

```
msg = hashlib.sha256(b'message').digest()
d = ECKey().generate()
P = d.get_pubkey()
print("message = {}".format(msg))
print("pubkey = {}".format(P.get_bytes()))

# Generate the nonce value k deterministically and get the nonce point R
# Method: use hashlib.sha256(bytes).digest() on the message and pubkey
k_bytes = hashlib.sha256(d.get_bytes() + msg).digest()
k = ECKey().set(k_bytes, True) 
R = k.get_pubkey()

# Check that nonce is quadratic residue modulo the field size
# If not, negate k
# Method: jacobi_symbol(int(y(R)), SECP256K1_FIELD_SIZE)
if jacobi_symbol(R.get_y(), SECP256K1_FIELD_SIZE) != 1:
    k.negate()

# Generate s = k + H(R_x|P|msg) * d
# Method: hashlib.sha256(bytes).digest() will give you the byte digest of the SHA256 of some bytes
# Turn that digest into a ECKey object called h, and then set s = k + h * d
h_b = hashlib.sha256(R.get_x().to_bytes(32, 'big') + P.get_bytes() + msg).digest()
h = ECKey().set(h_b, True)
s = k + h * d

# Generate sig = R_x|s
# Method: get the x bytes from R and concatenate with the secret bytes from s
sig = R.get_x().to_bytes(32, 'big') + s.secret.to_bytes(32,'big')

# Also, generate alternative sig with ECKey.sign_schnorr(msg)
sig2 = d.sign_schnorr(msg)

# Verify and compare signature(s)
assert P.verify_schnorr(sig, msg)
assert P.verify_schnorr(sig2, msg)
assert sig == sig2

print("Success!")
```

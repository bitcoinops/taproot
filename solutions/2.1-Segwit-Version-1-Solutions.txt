#### Part A

```
# Generate individual key pairs
privkey0 = ECKey()
privkey1 = ECKey()
privkey2 = ECKey()

privkey0.generate()
privkey1.generate()
privkey2.generate()

pk0 = privkey0.get_pubkey()
pk1 = privkey1.get_pubkey()
pk2 = privkey2.get_pubkey()

# Generate musig key
c_map, pk_musig = generate_musig_key([pk0, pk1])

# Multiply individual keys with challenges
privkey0_c = privkey0.mul(c_map[pk0])
privkey1_c = privkey1.mul(c_map[pk1])
pk0_c = pk0.mul(c_map[pk0])
pk1_c = pk1.mul(c_map[pk1])

# Create Segwit address (musig)
pubkey_data_musig = pk_musig.get_bytes()
program_musig = bytes([pubkey_data_musig[0] & 1]) + pubkey_data_musig[1:]
version = 0x01
address_musig = segwit_addr.encode("bcrt", version, program_musig)
print("2-of-2 musig: ", address_musig)

# Create Segwit address (single)
pubkey_data_single = pk2.get_bytes()
program_single = bytes([pubkey_data_single[0] & 1]) + pubkey_data_single[1:]
version = 0x01
address_single = segwit_addr.encode("bcrt", version, program_single)
print("Single key: ", address_single)
```

```
# Generate coins in Bitcoin Core wallet
blocks = test.nodes[0].generate(101)
balance = test.nodes[0].getbalance()
print('Balance:', balance)
```

```
# Send wallet transactions to segwit addresses (pk_musig, pk_single)
amount_btc = 0.05
txid_musig = test.nodes[0].sendtoaddress(address_musig, amount_btc)
txid_single = test.nodes[0].sendtoaddress(address_single, amount_btc)

# Reconstruct wallet transactions locally
tx_hex_musig = test.nodes[0].getrawtransaction(txid_musig) 
tx_hex_single = test.nodes[0].getrawtransaction(txid_single) 

tx_musig = CTransaction()
tx_single = CTransaction()
tx_musig.deserialize(BytesIO(bytes.fromhex(tx_hex_musig)))
tx_single.deserialize(BytesIO(bytes.fromhex(tx_hex_single)))
tx_musig.rehash()
tx_single.rehash()
```

```
# Use this function to find the output to spend
def find_output(tx, script):
    outputs = iter(tx.vout)
    output = next(outputs)
    output_index = 0
    while (output.scriptPubKey != script):
        output = next(outputs)
        output_index += 1
    return output, output_index

script_musig = CScript([OP_1, program_musig])
script_single = CScript([OP_1, program_single])

output_musig , index_musig = find_output(tx_musig, script_musig)
output_single , index_single = find_output(tx_single, script_single)
```

```
# Construct transcction which spends the musig segwit v1 output
spending_tx = CTransaction()
spending_tx.nVersion = 1
spending_tx.nLockTime = 0
outpoint_musig = COutPoint(tx_musig.sha256, index_musig)
spending_tx_in = CTxIn(outpoint = outpoint_musig)
spending_tx.vin = [spending_tx_in]

# Generate new Bitcoin Core wallet address
dest_addr = test.nodes[0].getnewaddress(address_type="bech32")
scriptpubkey = bytes.fromhex(test.nodes[0].getaddressinfo(dest_addr)['scriptPubKey'])

# Determine minimum fee required for mempool acceptance
min_fee = int(test.nodes[0].getmempoolinfo()['mempoolminfee'] * 100000000)

# Complete output which returns funds to Bitcoin Core wallet
amount_sat = int(amount_btc * 100000000)
dest_output = CTxOut(nValue=amount_sat-min_fee, scriptPubKey=scriptpubkey)
spending_tx.vout = [dest_output]
```

```
# Create sighash for ANY|ALL
hash_types = [0,1,2,3,0x81,0x82,0x83]
sighash_musig = TaprootSignatureHash(spending_tx, [output_musig], hash_types[4], input_index = 0, scriptpath = False)
 
# Sign for musig public key
nonce0 = generate_schnorr_nonce()
nonce1 = generate_schnorr_nonce()
R_agg, negated = aggregate_schnorr_nonces([nonce0.get_pubkey(), nonce1.get_pubkey()])
sig0 = sign_musig(privkey0_c, nonce0, R_agg, pk_musig, sighash_musig)
sig1 = sign_musig(privkey1_c, nonce1, R_agg, pk_musig, sighash_musig)
sig_agg = aggregate_musig_signatures([sig0, sig1])
sig_agg += hash_types[4].to_bytes(1, 'big')
```

```
# Construct transaction witness
witness = CScriptWitness()
witness.stack.append(sig_agg)
witness_in = CTxInWitness()
witness_in.scriptWitness = witness
spending_tx.wit.vtxinwit.append(witness_in)
 
# Serialize Schnorr transaction for broadcast
spending_tx_str = spending_tx.serialize().hex()
 
# Test mempool acceptance
print(test.nodes[0].testmempoolaccept([spending_tx_str]))
```

Part B

```
# Malleate TX to spend second input
outpoint_single = COutPoint(tx_single.sha256, index_single)
spending_tx_in = CTxIn(outpoint = outpoint_single)
spending_tx.vin.append(spending_tx_in)
sighash_single = TaprootSignatureHash(spending_tx, [output_musig, output_single], hash_types[0], input_index = 1, scriptpath = False)
sig_single = privkey2.sign_schnorr(sighash_single)

# Construct transaction witness for single pk output
witness = CScriptWitness()
witness.stack.append(sig_single)
witness_in_single = CTxInWitness()
witness_in_single.scriptWitness = witness
spending_tx.wit.vtxinwit.append(witness_in_single)

# Test mempool acceptance for malleated transaction
spending_tx_str = spending_tx.serialize().hex()
print(test.nodes[0].testmempoolaccept([spending_tx_str]))
```

#### 2.1.9 Generate segwit v1 addresses for a MuSig aggregate pubkey and a single-key
```
# Generate individual key pairs
privkey1 = ECKey().generate()
privkey2 = ECKey().generate()
pubkey1 = privkey1.get_pubkey()
pubkey2 = privkey2.get_pubkey()

# Generate a 2-of-2 aggregate MuSig key
# Method: use generate_musig_key()
c_map, agg_pubkey = generate_musig_key([pubkey1, pubkey2])

# Multiply individual keys with challenges
privkey1_c = privkey1.mul(c_map[pubkey1])
privkey2_c = privkey2.mul(c_map[pubkey2])
pubkey1_c = pubkey1.mul(c_map[pubkey1])
pubkey2_c = pubkey2.mul(c_map[pubkey2])

# Create a segwit v1 address for the MuSig aggregate pubkey
# Use segwit_addr.encode("bcrt", witness_version, witness_program)
pubkey_data_musig = agg_pubkey.get_bytes()
program_musig = bytes([pubkey_data_musig[0] & 1]) + pubkey_data_musig[1:]
version = 0x01
address_musig = segwit_addr.encode("bcrt", version, program_musig)
print("2-of-2 musig: ", address_musig)
```

#### 2.1.11 Instantiate a CTransaction object and populate the version, locktime inputs and output
```
# Construct transaction which spends the musig segwit v1 output
spending_tx = CTransaction()
spending_tx.nVersion = 1
spending_tx.nLockTime = 0
outpoint = COutPoint(tx_musig.sha256, output_index)
spending_tx_in = CTxIn(outpoint = outpoint)
spending_tx.vin = [spending_tx_in]

# Generate new Bitcoin Core wallet address
dest_addr = test.nodes[0].getnewaddress(address_type="bech32")
scriptpubkey = bytes.fromhex(test.nodes[0].getaddressinfo(dest_addr)['scriptPubKey'])
print("Destination address: {}\n".format(dest_addr))

# Determine minimum fee required for mempool acceptance
min_fee = int(test.nodes[0].getmempoolinfo()['mempoolminfee'] * 100000000)

# Complete output which returns funds to Bitcoin Core wallet
amount_sat = int(amount_btc * 100000000)
dest_output= CTxOut(nValue=amount_sat-min_fee, scriptPubKey=scriptpubkey)
spending_tx.vout = [dest_output]
print("Spending transaction:\n{}\n".format(spending_tx))

```

#### 2.1.12 Create a valid bip-schnorr signature for the MuSig aggregate pubkey
```
# Create sighash for ALL (0x00)
hash_types = [0,1,2,3,0x81,0x82,0x83]
sighash_musig = TaprootSignatureHash(spending_tx, [output], hash_types[0], input_index = 0, scriptpath = False)
 
# Generate individual nonces for participants and an aggregate nonce point
# Remember to negate the individual nonces if necessary
nonce1 = generate_schnorr_nonce()
nonce2 = generate_schnorr_nonce()
R_agg, negated = aggregate_schnorr_nonces([nonce1.get_pubkey(), nonce2.get_pubkey()])

# Create an aggregate signature
sig1 = sign_musig(privkey1_c, nonce1, R_agg, agg_pubkey, sighash_musig)
sig2 = sign_musig(privkey2_c, nonce2, R_agg, agg_pubkey, sighash_musig)
sig_agg = aggregate_musig_signatures([sig1, sig2])
print("Aggregate signature is {}\n".format(sig_agg.hex()))

# Construct transaction witness
witness = CScriptWitness()
witness.stack.append(sig_agg)
witness_in = CTxInWitness()
witness_in.scriptWitness = witness
spending_tx.wit.vtxinwit.append(witness_in)
 
# Serialize Schnorr transaction for broadcast
spending_tx_str = spending_tx.serialize().hex()
 
# Test mempool acceptance
assert test.nodes[0].testmempoolaccept([spending_tx_str])[0]['allowed']
print("Success!")
```
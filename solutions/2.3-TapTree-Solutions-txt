#### 2.1 - Constructing a Taptree output

```
# TODO: construct scripts using construct_pk()
TapLeafA.construct_pk(pubkeyA)
TapLeafB.construct_pk(pubkeyB)
TapLeafC.construct_pk(pubkeyC)
TapLeafD.construct_pk(pubkeyD)

# TODO: create a TapTree with our pubkey and huffman tree
taptree.key = pubkey_internal
taptree.huffman_constructor([(1,TapLeafA),(1, TapLeafB),(2,
TapLeafC),(3,TapLeafD)])

# TODO: Generate taproot output by `construct`ing the tree then using the taproot pubkey to create the segwit address
taproot_script, tweak, control_map = taptree.construct()
pubkey_taproot_bytes = bytes(taproot_script[2:])
segwit_address = program_to_witness(1, pubkey_taproot_bytes)
```

#### 2.2 - Spending a taproot output along a script path

```
# Sign transaction with tweaked private key.
# TODO: sig =
hash_types = [0,1,2,3,0x81,0x82,0x83]
sighash = TaprootSignatureHash(tx_script_spend, 
                               [taproot_output], 
                               hash_types[0], 
                               input_index = 0, 
                               scriptpath = True, 
                               tapscript = TapLeafA.script)
sig = privkeyA.sign_schnorr(sighash)

# TODO: Populate transaction witness.
witness = CScriptWitness()
witness.stack = [sig, TapLeafA.script, control_map[TapLeafA.script]]
witness_in = CTxInWitness()
witness_in.scriptWitness = witness
tx_script_spend.wit.vtxinwit.append(witness_in)

```